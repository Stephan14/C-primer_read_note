## 基础

### 左值和右值

当一个对象被当做右值使用时，其实是使用对象的值；当一个对象被当做左值使用时，其实是使用对象在内存中的位置。在使用右值的地方可以使用左值来代替，但是在使用左值的地方不可以使用右值来代替。

对于`decltype`关键字，如果表达式返回值是左值，则作用于该表达式的decltype得到一个引用类型；如果是右值，则不变。例如：

```
int a = 1;
int *p = &a;
decltype(*p) r = a; //r为int &类型
decltype(&p) pp = nullptr; //pp 为int** 类型，&p返回值为右值

```

### 求值顺序

**优先级只是规定了运算对象的组合方式，并没有说明运算对象按照什么顺序求值**

有四种运算符规定了求值顺序，分别是：`&&、||、？:、，`。

编写符合表达式的建议：
- 拿不准的时候强制使用括号来保证满足运算要求
- 如果改变某个运算对象的值，则在该表达式的其他地方不要再使用这个运算对象。但是当改变该对象的子表达式本身就是另外一个运算对象时除外，例如：*++iter


## 算数运算符

- 算数运算符的运算对象和求值结果都是右值。
- C++11规定商一律向零取整
- (-m) / n 和 m / (-n)等价于 - (m / n);(-m) % n 等价于 -（m % n）,m % (-n)等价于 -（m % n）
- 优先级如下：
![](http://res.cloudinary.com/bytedance14/image/upload/v1531642643/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7_2018-07-15_%E4%B8%8B%E5%8D%884.15.12.png)

## 逻辑运算符和关系运算符

- 逻辑运算符和关系运算符的运算对象和求值结果都是右值
- 对于逻辑与运算，只有左侧值为真的时才对右侧对象求值；对于逻辑或运算，只有左侧值为假时才对右侧对象求值
- 优先级如下：
![](http://res.cloudinary.com/bytedance14/image/upload/v1531642654/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7_2018-07-15_%E4%B8%8B%E5%8D%884.15.22.png)

## 赋值运算符

- 结果为左侧运算符，并且为左值
- 变量类型与右边的变量相同或者可以由右边对象转换得到
- 赋值运算符优先级比较低

```
int i = get_value();

while (i != 42) {
    i = get_value();
}

```
上述代码可以转化成如下的方式：

```
int i;
while ((i = get_value()) != 42) {
    i = get_value();
}
```
- 复合赋值运算符只求一次值

## 递增和递减运算符

- 前置和后置版本作用于左值运算对象，前置版本将对象本身作为**左值**返回，后置版本将原始对象的拷贝值作为**右值**返回
- 后置运算符优先级高于解引用运算符优先级

#### 运算对象可以任意顺序求值

如果一个子条表达式改变了某个运算对象的值，另一条子表达式又要使用该值，运算对象的求值顺序很关键。
```
while (beg != s.end() && !isspace(*beg)) {
    *beg = toupper(*beg++)
}
```
对于`*beg = toupper(*beg++)`编译器有两种了解：
- 先求左侧的值: *beg = toupper(*beg)
- 先求右侧的值: *(beg + 1) = toupper(*beg)

## 成员访问运算符

- 解引用运算符优先级低于点运算符，执行解引用的运算的子表达式必须加括号
- 箭头运算符作用一个指针类型对象，结果是一个左值
- 对于点运算符，如果成员所属的对象是左值，结果是左值；如果成员所属的对象是右值，结果为右值

## 条件运算符
- 当条件运算符的两个表达式都是左值或者能够转换到同一种左值类型，运算结果是左值；否则结果是右值
- 条件运算符优先级比较低，在长表达式中通常加括号

## 位运算符
- 如果运算对象是有符号的且为负数，左移会改变符号位的位置
- 右侧运算符不能为负，并且不能超过结果的位数，否则产生未定义的结果
- 移除边界之外的就被舍弃了
- 如果运算对象是小整形，它会被**自动提升**为较大整型类型
- 左移运算符在右侧插入值为0的二进制；右移运算符则依赖于其左侧运算对象的对象，如果该运算对象是无符号类型，左侧插入值为0的二进制位，如果该运算对象是带符号类型，则在左侧插入符号位的副本或者0的二进制位
- 移位运算符优先级比算术运算符低，比关系运算符、赋值运算符和条件运算符的优先级高

## sizeof运算符

- 返回一个表达式或者类型名字所占的字节数，满足右结合律，返回`size_t`类型
- 对于指针p进行运算`sizeof p`得到指针本身的所占的空间大小
- 对于解指针运算`sizeof *p`指针指向的对象所占的空间大小,即使p是未初始化的指针也没关系，sizeof不需要解引用也可以知道对象类型
- c++11支持使用作用域来获取类的成员大小
- 对于数组运算得到整个数组所占空间大小，sizeof不会把数组转换成指针处理
- 对于string对象作者vector进行运算返回该类型的固定部分大小

## 类型转换

### 何时发生隐式类型转换
- 在大多数表达式中，比int小的整数首先提升为较大的整数类型
- 在条件中，非布尔值转换成条件值
- 在初始化过程中，初始值转化成变量的类型，在赋值语句中，右侧运算对象转换成左侧运算对象
- 如果算数运算或者关系运算的运算对象有多种类型，需要转换成同一种类型
- 函数调用时发生类型转换

### 算数转换

算数运算符的对象将转换成最宽类型

#### 整型提升

把小正数转化成较大类型整数类型
- bool、char、signed char、unsigned char、short和unsigned short等类型来说，只要所有的可能值都能存在int里，则提升为int类型，否则提升为unsigned int类型
- 较大的char类型(wchar_t、char16_t、char32_t)提升成int、unsigned int、long、unsigned long、long long和unsigned long long中最小的一种类型

#### 无符号类型的运算对象

### 其他隐式类型转换

#### 数组转换成指针

在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针

- 当数组被用作decltype的参数，作为取地址符、sizeof运算符以及typeid等运算符的运算对象时，上述转换不发生
- 用引用初始化数组，上述转化不发生


#### 指针的转换
- 常量整数值0或者字面值nullptr能转换成任意指针类型
- 指向任意非常量的指针能转化成`void *`
- 指向任意对象的指针能转换成`const void*`

#### 转换成布尔类型
- 算术类型和指针类型可以向布尔类型自动转换

#### 转成常量
- 允许将指向非常量类型的指针或者引用转换成指向相应的常量类型
```
int i;
const int &j = i; //非常量转换成const int 引用
const int *p = &i; //非常量的地址转成const地址
int &r = j, *q = p; //错误，不允许转成非常量
```

#### 类类型定义的转换
- 编译器每次只能执行一种类类型转换

### 显示转换

#### 命名的强制类型转换
```
cast-name<type>(expression);
```
type是转换的目标类型而expression是要转换的值，如果type是引用类型结果为左值

#### static_cast
- 任何具有明确类型定义的转换，只要不包含底层const，都可以使用
- 较大算数类型赋值给较小算数类型使用static_cast可以关闭警告
- 当指针存放在void *类型的指针中，可以使用static_cast将其转换为原来的类型

#### const_cast
- const_cast只能去除运算对象的底层const，将其常量对象转化为非常量对象
- const_cast只改变常量属性

#### reinterpret_cast

对运算对象的位模式提供较低层次上的重新解释

#### 
