## 动态内存与智能指针
`shared_ptr`允许多个指针指向同一个对象
`unique_ptr`表示独占所指向的对象

### shared_ptr类
默认初始化的智能指针保存一个空指针，如果要使用智能指针则需要判断指针是不是为空。

#### make_shared函数
make_shared函数的参数必须与其类定义的构造函数匹配；如果不传递任何参数，对象就会进行值初始化
（默认值），通常配合`auto`关键字使用，例如：
```
auto p6 = make_shared<vector<string>>();
```

#### shared_ptr的拷贝和赋值

当一个shared_ptr初始化另一个shared_ptr、或者作为参数传递给另一个函数或者作为函数返回值时，
其计数器会增加

#### shared_ptr 销毁管理的对象
shared_ptr的析构函数会递减它所指向的对象的引用计数，如果引用计数变为0，shared_ptr的析构函数
会销毁对象，并释放他占用的内存

##### 使用动态内存的原因
1. 程序不知道需要使用多少对象（以容器类为例）
2. 程序不知道自己对象的准确类型
3. 程序需要在多个对象之间共享数据

### 直接管理内存

直接管理内存与使用智能指针的类不同，它不能依赖类对象拷贝、赋值和销毁操作的任何默认定义。
默认情况下，动态分配的对象是默认初始化，这意味着内置类型或者组合类型的对象的值将是未定义的，
而类类型对象将用默认构造函数进行初始化。但是也可以使用直接初始化的方式或者值初始化（有默认值），
例如：
```
string *ps = new string; //初始化为空字符串
int *pi = new int;      //执行未初始化的int
int *pi = new int(1024);  //1024
string *ps = new string(10, 'u');
string *ps = new string();
int *pi = new int();      //0
```

#### 动态分配const对象
const对象不能被修改，但是可以被销毁
注意：
1. 对象必须进行初始化
2. 返回的指针是一个指向const的指针
3. 对于定义一个默认构造函数的类类型，可以隐式初始化，其他类型必须显示初始化

#### 内存耗尽

```
int *p1 = new int;//如果分配失败，抛出std::bad_alloc
int *p2 = new (nothrow) int; //分配失败，返回一个空指针
```
#### 指针值和delete
传给delete的指针必须指向动态分配的内存或者是一个空指针。释放一个并非new 分配的内存，或者将相同的指针释放多次，其行为未定义。

delete之后将指针置为nullptr
