# 变量和基本类型
## 基本内置类型
	算术类型：字符、整数型、布尔值、和浮点数
	空类型：void
	内置类型的机器实现：可寻址的最小内存块称为“字节”，存储的基本单元称为“字”。为了赋予内
	存中某个地址明确的含义，必须先知道存储在该地址的数据类型，类型决定了数据所占的比特数
	以及应该如何解释该数据。
### 算术类型
	整型：字符和布尔类型
	浮点型：
	![C++标准规定的尺寸的最小值]
	(https://github.com/Stephan14/C-primer_read_note/blob/master/ch2/1.png?raw=true)
	一个char的大小和一个机器字节一样大，char16_t、wchar_t、char32_t、wchar_t类型用于
	确保可以存放机器最大的扩展字符集中的任意一个字符，其中char32_t和char16_t为unicode
	字符集服务。
### 带符号类型与无符号类型
	int、short、long和long long都是带符号的类型，可以在这些类型名前面添加unsigned就可
	以得到无符号类型，其中，unsigned int可以缩写为unsigned。与其他类型不同的是，字符分
	为三种类型：char、signed char和unsigned char。
#### 注意
	char和signed char并不一样，尽管字符有三种类型，但是字符的表现形式只有带符号和无符
	号。类型char会表现成上述两种类型中一种，具体是哪一种由编译器来定。
#### 选择类型的建议
	1.明确知道数值不可能为空的时候选择无符号类型。
	2.选用int类型执行整数运算，如果数值超过了int表示的范围，选择用long long类型。
	3.在算术表达式中不要使用char和bool，只有在存放字符或者布尔值时才使用它。因为char在
	一些机器上是有符号的，而在另一些机器上是无符号的，所以使用char特别容易出现问题，如果
	使用一个不是特别大整数，那么可以使用signed char和unsiged char类型。
	4.执行浮点数运算使用double类型，因为使用float通常精度不够而且双精度和单精度的类型的
	计算代价通常差不多。通常没有必要使用long long类型使用的精度，并且其运算消耗的性能比
	较高。
### 类型转换
	类型所能表示的值得范围决定了转换过程：
	1.当把一个非布尔类型的值赋值给一个布尔类型的值时，初始化值为0则结果为false，否则结果
	为true。
	2.当把一个布尔类型的值赋值给非布尔类型时，初始化得值为false则结果为0，初始化值为true
	则结果为1.
	3.当把一个浮点类型的值赋值给一个整数的时候，结果值将仅会保留浮点数中小数点之前的部分。
	4.当把一个整数赋值给一个浮点类型的值时，小数点部分可能变成0，如果该整数所占的空间超过
	了浮点类型，精度有可能由损失。
	5.当给无符号类型的数赋值一个超出其表示范围时，结果是初始值对无符号类型表示数值总数取
	模后的余数。
	6.当赋给一个带符号类型超出其表示范围的值时，其结果是未定的。
#### 含有无符号类型的表达式
	1.当一个表达式中有int值和无符号类型值时，会把这个int值转换成无符号类型，如果这个int
	值是负数，等价于把这个负数加上无符号类型的模。
	2.当从一个无符号类型值中减去一个值时，不管这个值是不是无符号类型，必须要保证结果不能
	是负值。
	例如：
```
	for( unsigned int u = 10; u>= 0; u--)
					cout<< u <<endl;
```
	以上代码会陷入死循环，因为unsigned int表示的值不可以是负数。
	可以改成这样的：
```
unsigned u = 11;
while( u > 0 )
{
		--u;
		cout<< u << endl;
}
```
#### 注意
	切勿混用带符号类型和无符号类型，当带符号类型取值为负时会出线异常结果。
### 字面值常量
##### 整型和浮点型字面值
	在满足一种类型能够容纳当前值的情况下，十进制字面值的类型是int、long和long long中尺
	寸中最小的那一个，并且，十进制字面值不可能是负数。八进制和十六进制字面值的类型是能容
	纳其数值的int、unsigned int、long、unsigned long、long long和unsigned long long
	中尺寸最小的那一个。
	浮点型字面值默认是一个double类型，可以使用后缀来表示其他的浮点型。
#### 字符和字符串字面值
	字符串字面值实际上是由常量字符构成的数组，在每个字符串的结尾添加一个空字符，所以字符
	串的实际长度要比它的内容多1.
			//分行书写字符串字面值
			cout<<"sdfsggf"
		  			"sdfdsfs";
#### 转义序列
	![C++标准规定的尺寸的最小值](https://github.com/Stephan14/C-primer_read_note/blob/master/ch2/2.png)
```
cout<<"\tHi!\n";
cout<<"Hi, \x4dO\115\n";//输出Hi MOM,转到新的一行
	cout<<'\115';           //输出M
```
###### 注意
	反斜线\后面跟着的八进制数字超过3个，只有前3个数字与\构成转义序列，例如：\1234表示两
	个字符：八进制数123和字符4；相反，\x要用到后面跟着的所有数字，\x1234表示一个16位的字
	符。
#### 指定字面值的类型
	通过添加如下的前缀或者后缀，可以改变字符、整型和浮点型字面值的类型。
	![指定字面值常量]
	(https://github.com/Stephan14/C-primer_read_note/blob/master/ch2/4.png)
#### 布尔字面值和指针字面值

## 变量
	变量的类型决定变量所占有的内存空间大小和布局方式、该空间能够存储的值的范围以及变量能参与的运算。
### 变量的定义
#### 初始化
	在同一条语句中可以使用先定义的变量来初始化后定义的变量，例如：
	double price = 109.99, discount = price * 0.16;
	double salePrice = applyDisocunt( price, discount );
##### 注意
	初始化与赋值是两件不同的事，初始化的含义是创建临时变量赋予一个值，而赋值的含义是把当前对象的当前值擦除，而一个新值代替。
#### 列表初始化
	想要为一个名为number的int类型初始化，可以有如下几种方式：
	int number = 0;
	int number = {0}；
	int number{0};
	int number(0);
	使用花括号进行初始化是C++11新标准的一部分，现在无论是	初始化对象和某些时候对新对象进行赋值，都可以使用花开括号进初始化。当使用内置类型的变量时，如果使用列表初始化且初始值存在丢失信息的风险，则编译器将会报错。
