# 变量和基本类型
## 基本内置类型
- 算术类型：字符、整数型、布尔值、和浮点数
- 空类型：void
- 内置类型的机器实现：可寻址的最小内存块称为“字节”，存储的基本单元称为“字”。为了赋予内存中某个地址明确的含义，必须先知道存储在该地址的数据类型，类型决定了数据所占的比特数以及应该如何解释该数据。

### 算术类型
- 整型：字符和布尔类型
- 浮点型：
	![C++标准规定的尺寸的最小值]
	(./1.png)
一个char的大小和一个机器字节一样大，char16_t、wchar_t、char32_t、wchar_t类型用于确保可以存放机器最大的扩展字符集中的任意一个字符，其中char32_t和char16_t为unicode
字符集服务。

### 带符号类型与无符号类型
int、short、long和long long都是带符号的类型，可以在这些类型名前面添加unsigned就可以得到无符号类型，其中，unsigned int可以缩写为unsigned。与其他类型不同的是，字符分为三种类型：char、signed char和unsigned char。

#### 注意
char和signed char并不一样，尽管字符有三种类型，但是字符的表现形式只有带符号和无符号。类型char会表现成上述两种类型中一种，具体是哪一种由编译器来定。

#### 选择类型的建议
- 明确知道数值不可能为空的时候选择无符号类型。
- 选用int类型执行整数运算，如果数值超过了int表示的范围，选择用long long类型。
- 在算术表达式中不要使用char和bool，只有在存放字符或者布尔值时才使用它。因为char在一些机器上是有符号的，而在另一些机器上是无符号的，所以使用char特别容易出现问题，如果使用一个不是特别大整数，那么可以使用signed char和unsiged char类型。
- 执行浮点数运算使用double类型，因为使用float通常精度不够而且双精度和单精度的类型的计算代价通常差不多。通常没有必要使用long long类型使用的精度，并且其运算消耗的性能比较高。

### 类型转换
类型所能表示的值得范围决定了转换过程：
- 当把一个非布尔类型的值赋值给一个布尔类型的值时，初始化值为0则结果为false，否则结果为true。
- 当把一个布尔类型的值赋值给非布尔类型时，初始化得为false则结果为0，初始化值为true则结果为1.
- 当把一个浮点类型的值赋值给一个整数的时候，结果值将仅会保留浮点数中小数点之前的部分。
- 当把一个整数赋值给一个浮点类型的值时，小数点部分可能变成0，如果该整数所占的空间超过了浮点类型，精度有可能由损失。
- 当给无符号类型的数赋值一个超出其表示范围时，结果是初始值对无符号类型表示数值总数取模后的余数。
- 当赋给一个带符号类型超出其表示范围的值时，其结果是未定的。

#### 含有无符号类型的表达式
- 当一个表达式中有int值和无符号类型值时，会把这个int值转换成无符号类型，如果这个int值是负数，等价于把这个负数加上无符号类型的模。
- 当从一个无符号类型值中减去一个值时，不管这个值是不是无符号类型，必须要保证结果不能是负值。
	例如：
```
	for( unsigned int u = 10; u>= 0; u--)
					cout<< u <<endl;
```
以上代码会陷入死循环，因为unsigned int表示的值不可以是负数。
可以改成这样的：
```
unsigned u = 11;
while( u > 0 )
{
		--u;
		cout<< u << endl;
}
```
#### 注意
切勿混用带符号类型和无符号类型，当带符号类型取值为负时会出线异常结果,因为带符号数据会自动转化成无符号数据

### 字面值常量

##### 整型和浮点型字面值
在满足一种类型能够容纳当前值的情况下，十进制字面值的类型是int、long和long long中尺寸中最小的那一个，并且，十进制字面值不可能是负数。八进制和十六进制字面值的类型是能容
纳其数值的int、unsigned int、long、unsigned long、long long和unsigned long long中尺寸最小的那一个。
浮点型字面值默认是一个double类型，可以使用后缀来表示其他的浮点型。

#### 字符和字符串字面值
字符串字面值实际上是由常量字符构成的数组，在每个字符串的结尾添加一个空字符，所以字符串的实际长度要比它的内容多1.
			//分行书写字符串字面值，实际上是一个整体
			cout << "sdfsggf"
		  	        "sdfdsfs";

#### 转义序列
	![C++标准规定的尺寸的最小值](https://github.com/Stephan14/C-primer_read_note/blob/master/ch2/2.png)
```
cout<<"\tHi!\n";
cout<<"Hi, \x4dO\115\n";//输出Hi MOM,转到新的一行
	cout<<'\115';           //输出M
```

###### 注意
反斜线\后面跟着的八进制数字超过3个，只有前3个数字与\构成转义序列，例如：\1234表示两个字符：八进制数123和字符4；相反，\x要用到后面跟着的所有数字，\x1234表示一个16位的字符。

#### 指定字面值的类型
通过添加如下的前缀或者后缀，可以改变字符、整型和浮点型字面值的类型。
	![指定字面值常量]
	(https://github.com/Stephan14/C-primer_read_note/blob/master/ch2/4.png)

#### 布尔字面值和指针字面值

## 变量
变量的类型决定变量所占有的内存空间大小和布局方式、该空间能够存储的值的范围以及变量能参与的运算。
### 变量的定义
#### 初始化
在同一条语句中可以使用先定义的变量来初始化后定义的变量，例如：
```
double price = 109.99, discount = price * 0.16;
double salePrice = applyDisocunt( price, discount );
```
##### 注意
初始化与赋值是两件不同的事，初始化的含义是创建临时变量赋予一个值，而赋值的含义是把当前对象的当前值擦除，而一个新值代替。
#### 列表初始化
想要为一个名为number的int类型初始化，可以有如下几种方式：
```
int number = 0;
int number = {0}；
int number{0};
int number(0);
```
使用花括号进行初始化是C++11新标准的一部分，现在无论是	初始化对象和某些时候对新对象进行赋值，都可以使用花开括号进初始化。当使用内置类型的变量时，如果使用列表初始化且初始值存在丢失信息的风险，则编译器将会报错。

#### 默认初始化
定义于任何函数体之外的内置类型的变量被初始化为0，定义于函数体内部的内置变量将不被初始化

### 变量声明和定义关系
如果想声明一个变量而不是定义它，可以在变量前面加extern，而且不要显示初始化它，例如：
```
extern int i;//声明
extern double pi = 3.14;//定义
```

## 复合类型

### 引用
- 引用必须被初始化
- 引用不是对象，不能定义引用的引用
- 除了非常量引用，其他引用的类型必须与绑定的对象类型严格匹配，并且不能与绑定的表达式的结果绑定到一起

### 常量引用
允许常量引用绑定到非常量的对象、字面值和表达式，例如：
```
int i = 42;
const int &r1 = i;
const int &r2 = 42;
const int &r3 = r1 * 2;
```
之所以常量引用可以这么用原因如下，以如下代码为例：
```
double dval = 3.14;
const int &r1 = dval;
```
其实编译器把上述代码转化成如下的形式：
```
double dval = 3.14;  
const int temp = dval; //将变量转化成临时变量来存储
const int &r1 = dval;  //引用绑定到临时变量上
```

#### 注意
常量引用可以绑定到一个非const对象，但是不可以通过该常量引用改变该对象，可以通过其他非常量对象改变

### 指针

1. 指针本身就是一个对象，可以在生命周期中指向不同的对象
2. 指针无需在定义时初始化

#### 注意
建议初始化所有指针

### 符合类型的声明

```
int *p1, p2;//p1为int指针 p2为int类型
```

## const限定符

const对象必须初始化，初始值可以是任意表达式的值

用一个对象去初始化另外一个对象，则他们是不是const是没关系的：
```
int i = 2;
const int ci = i;  //正确
int j = ci;        //正确
```

### const仅在文件作用域内有效

编译器在编译的时候将const变量全部替换，为了避免对同一个变量的重复定义，默认情况下，const变量只在文件作用域内有效。

为了达到const变量的共享的目的，在变量的定义和声明的时候都使用extern，这样只需要定义一次，使用多次了。

### const的引用

由于不可以改变引用所绑定的对象，所以引用为常量

不可以让一个非常量引用指向一个常量对象

const引用与一个非const类型对象绑定，但是不可以通过次引用改变const，可以通过其他方式改变

### 指针和const

和const引用一样，指向常量的指针没有规定其指向的对象必须是一个常量

### 顶层const

顶层const表示任意对象本身是个常量

底层const表示与指针和复合类型所指的对象是个常量

```
int i = 0;
int *const p1 = &i;  //顶层const
const int ci = 42;   //顶层const
const int *p2 = &ci; //底层const
const int &r = ci;   //所有声明引用的const都是底层const
p2 = &i;             //int *可以转化成const int *
```

#### 注意
对于拷贝操作，输入输出操作必须拥有相同类型的*底层const*或者两者的数据类型可以转换，对于顶层const没有要求。

### constexpr和常量表达式

常量表达式表示值不会改变并且在*编译*过程中就会得到计算结果的表达式

一个对象是否是常量表达式由数据类型和初始值两部分组成，数据类型一般要求为常量类型（算术类型、引用和指针）

constexpr指针的初始值必须是nullptr或者0，或者存在于某一个固定地址的对象（一般是定义于函数体之外的对象）

## 处理类型

### 类型别名

使用typedef定义类型别名吗(当类型名过长时可以使用)，也可以使用using定义别名，如下：

```
typedef double wages;
using SI = Slase;
```

#### 注意

```
typedef char *pstring;
const pstring cstr = 0;   //指向字符的常量指针

const char *cstr = 0;     //指向字符常量的指针
```
以上两种声明方式不同，不要理解错误了


### auto类型说明

为了解决在声明变量的时候不需要知道类型名字，让编译器通过初始化的值推断变量类型

在一条语句中声明多个变量的时候，所有变量的初始类型必须一致


```
int i = 0, &r = i;
const int ci = i, &cr = ci;
//auto中一般会忽略掉顶层const，同时底层const则会保留下来
auto d = &i;     //d是一个整型指针
auto e = &ci;    //e是一个整数常量的指针
```

### decltype类型指示符

如果不想通过初始值来判断变量类型，编译器通过分析相应参数的类型来确定变量的类型，在这个过程中如果参数是函数，并没有执行相应的函数
