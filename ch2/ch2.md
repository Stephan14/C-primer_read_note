#变量和基本类型
##基本内置类型
	算术类型：字符、整数型、布尔值、和浮点数
	空类型：void
	内置类型的机器实现：可寻址的最小内存块称为“字节”，存储的基本单元称为“字”。为了赋予内存中某个地址明确的含义，必须先知道存储在该地址的数据类型，类型决定了数据所占的比特数以及应该如何解释该数据。
###算术类型
	整型：字符和布尔类型
	浮点型：
	
	![C++标准规定的尺寸的最小值](http://1.png)
	一个char的大小和一个机器字节一样大，char16_t、wchar_t、char32_t、wchar_t类型用于确保可以存放机器最大的扩展字符集中的任意一个字符，其中char32_t和char16_t为unicode字符集服务。
###带符号类型与无符号类型
	int、short、long和long long都是带符号的类型，可以在这些类型名前面添加unsigned就可以得到无符号类型，其中，unsigned int可以缩写为unsigned。与其他类型不同的是，字符分为三种类型：char、signed char和unsigned char。
####注意
	char和signed char并不一样，尽管字符有三种类型，但是字符的表现形式只有带符号和无符号。类型char会表现成上述两种类型中一种，具体是哪一种由编译器来定。
####选择类型的建议
	1.明确知道数值不可能为空的时候选择无符号类型。
	2.选用int类型执行整数运算，如果数值超过了int表示的范围，选择用long long类型。
	3.在算术表达式中不要使用char和bool，只有在存放字符或者布尔值时才使用它。因为char在一些机器上是有符号的，而在另一些机器上是无符号的，所以使用char特别容易出现问题，如果使用一个不是特别大整数，那么可以使用signed char和unsiged char类型。
	4.执行浮点数运算使用double类型，因为使用float通常精度不够而且双精度和单精度的类型的计算代价通常差不多。通常没有必要使用long long类型使用的精度，并且其运算消耗的性能比较高。
	
###类型转换
	类型所能表示的值得范围决定了转换过程：
		1.当把一个非布尔类型的值赋值给一个布尔类型的值时，初始化值为0则结果为false，否则结果为true。
		2.当把一个布尔类型的值赋值给非布尔类型时，初始化得值为false则结果为0，初始化值为true则结果为1.
		3.当把一个浮点类型的值赋值给一个整数的时候，结果值将仅会保留浮点数中小数点之前的部分。
		4.当把一个整数赋值给一个浮点类型的值时，小数点部分可能变成0，如果该整数所占的空间超过了浮点类型，精度有可能由损失。
		5.当给无符号类型的数赋值一个超出其表示范围时，结果是初始值对无符号类型表示数值总数取模后的余数。
		6.当赋给一个带符号类型超出其表示范围的值时，其结果是未定的。
####含有无符号类型的表达式
	1.当一个表达式中有int值和无符号类型值时，会把这个int值转换成无符号类型，如果这个int值是负数，等价于把这个负数加上无符号类型的模。
	2.当从一个无符号类型值中减去一个值时，不管这个值是不是无符号类型，必须要保证结果不能是负值。
	例如：
				for( unsigned int u = 10; u>= 0; u--)
					cout<< u <<endl;
	以上代码会陷入死循环，因为unsigned int表示的值不可以是负数。
	可以改成这样的：
				unsigned u = 11;
				while( u > 0 )
				{
					--u;
					cout<< u << endl;
				}
####注意
	切勿混用带符号类型和无符号类型，当带符号类型取值为负时会出线异常结果。
	