## 定义抽象数据类型

### 定义改进的Sales_data类

#### 定义成员函数

- 所有成员都必须在类里面声明
- 成员函数体可以定义在类内也可以定义在类外，定义在类内部的函数是隐式的内联函数
- 成员函数通过一个名为this的额外隐式参数来访问调用它的那个对象。this是一个常量指针（例如：Sales_data *const 类型）
- 在成员函数内部可以直接使用调用该函数的对象的成员

#### 引入const成员函数
默认情况下，this指针是指向类类型非常量版本的常量指针，但是这意味着不可以把this绑定到一个常量对象上。因此，可以通过将const关键字放到成员函数的参数列表之后，将this指针声明成指向常量的指针。

- 常量对象、以及常量对象的引用或者指针都只能调用常量成员函数

#### 类作用域和成员函数

编译器首先编译成员的声明，然后才轮到成员函数体，因此，成员函数可以随意使用类中的其他成员而不需要在意声明的次序

#### 在类外定义成员函数

在类外定义成员函数的时，返回类型、参数列表和函数名必须与类内部声明的保持一致。如果为const成员函数，定义时也必须在参数列表后面明确指定const属性。

#### 定义一个返回this对象的函数
内置的赋值运算符把它的左侧运算对象当成一个左值返回，因此，必须返回一个引用类型（Sales_data &）,函数体重返回return *this。

### 定义类相关的非成员函数

### 构造函数
- 构造函数没有返回类型
- 类可以有多个构造函数，构造函数之间参数列表和参数的数量之间必须有区别
- 构造函数不能被声明为const类型

#### 合成的默认构造函数
如果没有显示的定义构造函数，那么编译器会隐式定义一个默认构造函数，默认构造函数无需任何实参，其初始化逻辑如下：
- 如果存在类内初始值，用它来初始化成员
- 否侧，默认初始化成员

#### 某些类不能依赖于合成的默认构造函数
- 一旦定义了其他构造函数，不会生成默认构造函数
- 如果类中含有内置类型或者复合类型（指针和数组），它们被默认初始化时，值是未定义的；只有内置类型和复合类型被设置初始值时，才适合使用默认构造函数
- 类中包含其他类类型成员并且这些类型也没有默认构造函数

#### =default
既需要其他类型的构造函数，也需要默认构造函数；既可以和类的声明一起出现在类的内部，此时，该构造函数为内联的；也可以作为定义出现在类的外部，此时构造函数不是内联的

##### 注意
如果类中有内置类型或者复合类型，则需要为其提供初始值

#### 构造函数初始值列表
当某个数据成员被初始化列表忽略时，使用和默认构造函数相同的方式隐式初始化该数据成员

#### 在类外部定义构造函数

### 拷贝、赋值和析构

在我们不主动定义拷贝、赋值和析构时，编译器会主动替我们合成。

#### 某些类不能依赖于合成版本
- 某些类需要依赖对象之外的资源（比如：依赖指针但是vector和string除外）

### 访问控制与封装

某个访问说明符在类中能出现多少次也没有严格的限制

#### 使用class或者struct关键字

`struct`关键字默认是public，`class`关键字默认是private

#### 友元
类可以允许通过将其他类或者函数设置为友元来访问其私有成员，并且友元声明只能出现在类定义的内部，类内具体位置不限
