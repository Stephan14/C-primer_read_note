## 函数

### 函数基础

#### 形参和实参

- 形参和实参的类型必须保持一致
- 但是没有规定实参的求值顺序

#### 局部对象

##### 自动对象
局部变量随着函数的控制路径经过变量的创建语句时创建，函数到达定义所在的块末尾时销毁它，称这种对象为**自动对象**。形参是一种自动变量；局部变量也是一种自动变量。

##### 局部静态对象
贯穿函数调用以及其之后的局部变量为局部静态对象，在函数的执行路径第一次创建时**初始化**，直到程序终止时才完成，即使对象所在的函数执行完成对其也没有影响。如果局部静态变量没有经过**显式初始化**，则执行默认初始化。

#### 函数声明

函数只可以被定义一次，但是可以被声明一次。

#### 分离式编译

### 参数传递

形参的类型决定了形参和实参的交互方式。如果形参是引用类型，它将绑定到对应的实参上，否则，将实参的值拷贝给形参。

#### 传值参数

##### 指针形参
可以使用指针的形参访问函数外部的对象，在C++中建议使用引用代替。

#### 传引用参数
改变引用就是改变实例对象，对于某些不支持拷贝操作时，函数只能通过引用形参访问该类型的对象
- 当参数无需修改时最好将其设置为常量引用类型
- 使用引用作为参数可以返回值使用

#### const形参和实参

- **实参初始化形参的时候会忽略掉顶层const**,当形参有顶层const时，传给他常量对象和非常量对象
- 函数重载时忽略掉顶层const

##### 指针或者引用形参参与const
- 可以使用非常量来初始化一个底层const对象
- 一个普通的对象必须使用同一个类型的对象初始化
- 尽量使用常量引用，使用普通引用而不是常量引用会极大的限制住函数所能接受的实参类型，不能把**const对象、字面值或者需要类型转换的对象传给普通的引用形参**

#### 数组形参

数组的特殊性质：
- 不允许拷贝数组
- 数组通常会被转成指针

以下三种函数声明等价：
```
void print(const int*);
void print(const int[]);
void print(const int[10]);
```

##### 注意
以数组作为形参的函数也必须确保使用数组时不会越界

##### 管理指针形参的三种方式
- 使用标记指定数组长度
要求数组本身包含一种结束标记，例如C字符串中的空格
- 使用标准库规范
传递指向数组首元素和尾后元素的指针
- 显示传递一个表示数组大小的形参

##### 数组形参和const
关于引用的讨论适用于指针，当不需要对数组的形参执行写操作的时候，数组的形参应该指向const指针；只有当函数确实需要改变元素值的时候，才能把形参定义成指向非常量的指针。

##### 数组引用形参
```
void print(int (&arr)[10]) {
    for (auto elem : arr) {
        cout << elem << endl;
    }
}
int i = 0, j[2] = {0, 1};
int k[10]= {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
print(&i);  //错误：实参不是含有10个整数的数组
print(j);   //错误：实参不是含有10个整数的数组
print(k);   //正确
```
`&arr`两端的括号必不可少，否则声明成引用的数组，并且数组的大小构成数组类型一部分。

##### 传递多维数组
```
void print(int (*matrix)[10], int rowSize);
```

###### 注意
- `int *matrix[10]`表示10个指针构成的数组
- `int (*matrix)[10]`表示指向含有10个整数的数组的指针

### 返回类型和return语句

#### 无返回值函数
- 返回void的语句不一定要求有return语句，因为这类函数最后会隐式执行一个return语句
- 可以使用return语句提前退出

#### 有返回值函数
- return的返回类型必须与函数返回类型相同，或者能够隐式转换成函数返回类型

##### 值是如何被返回的
- 返回局部变量时，返回的是这个变量的拷贝，为一个临时变量
- 返回引用类型时，其返回的是const类型的引用，不会发生对象拷贝
- 不要返回局部对象的指针或者引用

##### 引用返回左值
调用一个返回引用的函数得到左值，其他返回类型为右值。可以像使用左值一样来使用函数的调用，特别是返回非常量引用的函数。

##### 列表初始化返回值
C++11规定函数可以返回花括号包围的值的列表。如果函数返回的是内置类型，则花括号包含的列表最多包含一个值，且该值的占用空间大于目标类型的空间；如果函数返回类类型，则由类本身定义初始值如何使用。
```
int test(int a) {
    if (a == 1) {
        return {2};
    } else {
        return {};
    }
}
```
##### 返回数组指针

通过定义指针别名实现返回指针，例如：
```
typedef int arrT[10]; //[10]放在后面
using arrT = int[10];

arrT* func(int i);
```

- 声明一个返回数组指针的函数
形式如下：
```
Type (*function(par_list))[dimension]
```
例如：
`int (*func(int i))[10]`
    按照如下方式理解：
    - `func(int i)`表示一个需要int类型的实参的函数
    - `(*func(int i))`可以对函数的调用结果执行解引用
    - `(*func(int i))[10]`解引用将得到一个大小为10的数组
    - `int (*func(int i))[10]`数组额元素为int类型

- 使用尾置返回类型
C++11中任何函数都可以使用尾置返回类型，对于返回类型比较复杂的函数比较有效。使用一个`->`开始，例如：
```
auto func1(int arr[][3], int n) -> int(*)[3] {
    return &arr[n];
}
```

- 使用decltype
如果知道函数返回类型指向的对象，可以使用decltype声明：
```
int odd[] = {1, 3, 5, 7, 9};
int even[] = {0, 2, 4, 6, 8};
decltype(odd) *arrPtr(int i ) {//需要加一个*转化成指针
    return (i % 2)? &odd, &even;
}
```

### 函数重载

##### 定义重载函数
- 不允许两个函数除了返回类型外其他所有要素都相同

##### 重载和const形参
- 顶层const的形参（指针或者引用）无法与一个没有顶层const的形参区分开来

##### const_cast和重载
当有以下一个函数：
```
const string &shortString(const string &s1, const string &s2)
{
    return s1.size() <= s2.size()? s1 : s2;
}
```
需要实现一种返回普通引用的函数，可以使用const_cast实现：
```
string &shortString(string &s1, string &s2)
{
    auto &r = shortString(const_cast<const string&>(s1),
                            const_cast<const string&>(s2));
    return const_cast<string &>(r);
}
```

#### 重载与作用域
- 在不同的作用域中无法重载函数名，内层作用域中声明的名字会隐藏外层作用域中声明的同名实体


### 特殊用途语言特性

#### 默认实参
- 一旦某一个参数被赋予了默认值，它后面的所有形参必须有默认值
- 调用时，只能省略尾部实参
- 在给定作用域中，一个形参只能被赋予一次默认实参，后续声明只能为之前的没有默认值的形参添加默认实参
- 局部变量不能够作为默认实参,函数默认值在调用时进行求值

#### 内联函数和constexpr函数

##### 内联函数
内联函数会在编译的过程中将函数展开，从而降低函数调用的开销。一般来说，内联机制用来优化规模较小、流程直接、频繁调用的函数，有时编译器会忽略这个优化。

##### constexpr函数
定义constexpr函数的几个要求：
- 函数返回值类型及所有**形参**的类型都是字面值类型（只有内置类型存在字面值）
- 函数中必须有且只有一个return语句

执行时编译器把对constexpr函数调用替换成其结果值，为了能够在编译过程中随时展开，constexpr函数被隐式指定为内联函数

**constexpr函数的返回值并非必须是一个常量**，例如：
```
constexpr size_t scale(size_t cnt) {return 42 * cnt; }
```
当scale的实参是常量表达式时，返回值是常量表达式；否侧，不是，如果当作常量表达式来使用编译器会报错。

内联函数和constexpr可以多次定义，但是多次定义必须是相同的，所以可把定义放在头文件。

#### 调试帮助

##### assert预处理宏
```
assert(expr)
```
如果expr为假，输出信息并终止程序；如果为真，则什么都不做

##### NDEBUG预处理变量
如果定义了NDEBUG,则assert什么也不做，默认状态下没有定义NDEBUG，此时assert将执行运行时检查。

### 函数匹配

##### 确定候选函数和可行函数

1. 根据函数名字是否先相同和声明是否在调用点可见来确定*候选函数*
2. 根据形参数量和本地调用的实参数量是否相同以及每个实参类型是否跟对应的形参类型是否相同或者可以转换成形参类型确定*可行函数*

##### 寻找最佳匹配

在完成上述两个步骤之后，就是开始寻找最佳匹配函数，其思想就是：实参类型与形参类型越接近，匹配的越好

##### 含有多个形参的函数匹配

编译器一次检查每个实参一确定那个函数是最佳匹配函数。如果*有且只有一个*函数满足下列条件，则匹配成功：
- 该函数每个实参的匹配都不劣于其他可行函数需要的匹配
- 至少一个实参的匹配优于其他可行函数提供的匹配

#### 实参类型转换

实参到形参的类型转换级别划分如下：
1. 精确匹配：
  - 实参和形参类型相同
  - 实参从数组类型或者函数类型转换成对应的指针类型
  - 向实参添加顶层const或者从实参中删除顶层const
2. 通过const转换匹配
  - 去掉底层const的转换不可以
3. 通过类型提升进行匹配
4. 通过算数类型转换或者指针类型转换
  - 所有算数类型的转换优先级相同
5. 通过类类型转换实现匹配

##### 注意
如果两个函数的唯一区别在于它的指针形参或者引用形参指向常量或者非常量，则编译器通过判断参数是不是常量来决定调用那个函数：如果是，调用常量引用后者指针的参数；如果不是，调用普通指针或者引用的参数。

### 函数指针

函数指针的类型由它的返回类型和形参类型共同决定。

#### 使用函数指针

```
//未初始化
bool (*pf)(const stirng &, const string &);
//赋值
pf = lengthCompare
pf = &lengthCompare
//调用函数，无需解引用
bool b1 = pf("sss", "bbbb")
bool b2 = (*pf)("sss", "bbbb")
bool b3 = lengthCompare("sss", "bbbb")
```
##### 注意
不同函数类型的指针间不存在转换规则，但是可以赋值`nullptr`

#### 函数指针形参
*和数组类似，函数指针形参看起来是函数类型，实际上确是当成指针使用。*

可以使用`typedef`定义别名，例如：
```
typedef bool Func(const string&, const string&);
typedef bool decltype(lengthCompare) Func;
typedef bool (*Func)(const string&, const string&);
typedef bool decltype(lengthCompare) *Func;
```

##### 注意

`decltype`返回函数类型，不会将函数类型自动转换成指针类型。

#### 返回指向函数的指针

函数的返回类型必须写成指针形式，与函数类型形参不同，编译器不会自动将函数类型转换成对应的指针类型处理。通过使用`using`定义函数的别名：
```
using F = int(int*, int);
using PF = int(*)(int*, int);

PF f1(int);
F f2(int); //错误
F* f3(int);

auto f1(int) -> int (*)(int*, int);
```

#### 将auto和decltype用于函数指针类型
